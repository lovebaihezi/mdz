const std = @import("std");

const TestCase = struct {
    markdown: []const u8,
    html: []const u8,
    example: u64,
    start_line: u64,
    end_line: u64,
    section: []const u8,
};

const spec_url = "https://spec.commonmark.org/0.31.2/spec.json";

fn escapeZigString(allocator: std.mem.Allocator, input: []const u8) ![]u8 {
    var result = std.ArrayList(u8).init(allocator);
    defer result.deinit();

    for (input) |char| {
        switch (char) {
            '\\' => try result.appendSlice("\\\\"),
            '"' => try result.appendSlice("\\\""),
            '\n' => try result.appendSlice("\\n"),
            '\r' => try result.appendSlice("\\r"),
            '\t' => try result.appendSlice("\\t"),
            else => try result.append(char),
        }
    }

    return result.toOwnedSlice();
}

fn sanitizeSectionName(allocator: std.mem.Allocator, section: []const u8) ![]u8 {
    var result = std.ArrayList(u8).init(allocator);
    defer result.deinit();

    for (section) |char| {
        switch (char) {
            'a'...'z', 'A'...'Z', '0'...'9' => try result.append(std.ascii.toLower(char)),
            else => try result.append('_'),
        }
    }

    return result.toOwnedSlice();
}

pub fn main() !void {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();
    const allocator = arena.allocator();

    var client = std.http.Client{
        .allocator = allocator,
    };
    defer client.deinit();

    var response_body = std.ArrayList(u8).init(allocator);
    defer response_body.deinit();

    std.debug.print("Fetching test cases from {s}...\n", .{spec_url});
    const result = try client.fetch(.{
        .location = .{
            .url = spec_url,
        },
        .response_storage = .{ .dynamic = &response_body },
    });

    if (result.status != .ok) {
        std.debug.print("Failed to fetch spec.json: {}\n", .{result.status});
        return error.HttpRequestFailed;
    }

    std.debug.print("Parsing test cases...\n", .{});
    var parsed = try std.json.parseFromSlice([]TestCase, allocator, response_body.items, .{
        .ignore_unknown_fields = true,
    });
    defer parsed.deinit();

    const test_cases = parsed.value;

    std.debug.print("Successfully parsed {d} test cases.\n", .{test_cases.len});

    // Generate test file
    std.debug.print("Generating test file...\n", .{});
    const output_file = try std.fs.cwd().createFile("src/commonmark_spec_tests.zig", .{});
    defer output_file.close();

    const writer = output_file.writer();

    // Write file header
    try writer.writeAll(
        \\//! Generated CommonMark specification tests
        \\//! This file is auto-generated by scripts/commonmark-test-gen.zig
        \\//! Do not edit manually.
        \\
        \\const std = @import("std");
        \\const testing = std.testing;
        \\const Allocator = std.mem.Allocator;
        \\const Parser = @import("mdz.zig").parser.Parser;
        \\const Lexer = @import("mdz.zig").lexer.Lexer;
        \\const Block = @import("mdz.zig").mir.Block;
        \\
        \\const page_size = 4096 * 1024;
        \\
        \\fn parseMarkdownToHtml(allocator: Allocator, markdown: []const u8) ![]u8 {
        \\    var result = std.ArrayList(u8).init(allocator);
        \\    const result_writer = result.writer();
        \\
        \\    var parser = Parser.init(allocator);
        \\    var buffer: [page_size]u8 = undefined;
        \\    @memcpy(buffer[0..markdown.len], markdown);
        \\    var lexer = Lexer.init(buffer[0..markdown.len]);
        \\
        \\    while (try parser.next(&lexer)) |block| {
        \\        try block.writeHTML(buffer[0..markdown.len], result_writer);
        \\    }
        \\
        \\    return result.toOwnedSlice();
        \\}
        \\
        \\fn normalizeHtml(allocator: Allocator, html: []const u8) ![]u8 {
        \\    var result = std.ArrayList(u8).init(allocator);
        \\    defer result.deinit();
        \\
        \\    for (html) |char| {
        \\        switch (char) {
        \\            '\r' => {}, // Skip \r, normalize to \n only
        \\            else => try result.append(char),
        \\        }
        \\    }
        \\
        \\    return result.toOwnedSlice();
        \\}
        \\
        \\
    );

    // Generate test functions
    for (test_cases) |test_case| {
        const escaped_markdown = try escapeZigString(allocator, test_case.markdown);
        const escaped_html = try escapeZigString(allocator, test_case.html);
        const sanitized_section = try sanitizeSectionName(allocator, test_case.section);

        try writer.print(
            \\// Example {d} from section "{s}" (lines {d}-{d})
            \\test "commonmark_spec_{s}_{d}" {{
            \\    const allocator = testing.allocator;
            \\    const markdown = "{s}";
            \\    const expected_html = "{s}";
            \\
            \\    const actual_html = try parseMarkdownToHtml(allocator, markdown);
            \\    defer allocator.free(actual_html);
            \\
            \\    const normalized_expected = try normalizeHtml(allocator, expected_html);
            \\    defer allocator.free(normalized_expected);
            \\
            \\    const normalized_actual = try normalizeHtml(allocator, actual_html);
            \\    defer allocator.free(normalized_actual);
            \\
            \\    try testing.expectEqualStrings(normalized_expected, normalized_actual);
            \\}}
            \\
            \\
        , .{
            test_case.example,
            test_case.section,
            test_case.start_line,
            test_case.end_line,
            sanitized_section,
            test_case.example,
            escaped_markdown,
            escaped_html,
        });
    }

    std.debug.print("Generated {d} test cases in src/commonmark_spec_tests.zig\n", .{test_cases.len});
}
